<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kaobeimao.github.io</id>
    <title>kaobeimao</title>
    <updated>2019-10-18T07:45:20.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kaobeimao.github.io"/>
    <link rel="self" href="https://kaobeimao.github.io/atom.xml"/>
    <subtitle>舒服嗷铁汁</subtitle>
    <logo>https://kaobeimao.github.io/images/avatar.png</logo>
    <icon>https://kaobeimao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, kaobeimao</rights>
    <entry>
        <title type="html"><![CDATA[JS基础知识点整理]]></title>
        <id>https://kaobeimao.github.io/post/uJ61PmWre</id>
        <link href="https://kaobeimao.github.io/post/uJ61PmWre">
        </link>
        <updated>2019-10-10T07:00:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="内置类型">内置类型</h2>
<blockquote>
<p>JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）</p>
</blockquote>
<h3 id="原始primitive类型-基本类型">原始（Primitive）类型 | 基本类型</h3>
<p>6 种原始值，分别是：</p>
<ul>
<li><strong>boolean</strong></li>
<li><strong>null</strong></li>
<li><strong>undefined</strong></li>
<li><strong>number</strong></li>
<li><strong>string</strong></li>
<li><strong>symbol</strong></li>
</ul>
<p>JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 <strong>IEEE 754</strong> 标准实现。<strong>NaN</strong> 也属于<strong>number</strong> 类型，并且 <strong>NaN</strong> 不等于自身。</p>
<p>原始类型存储的都是<strong>值</strong>，是没有<strong>函数</strong>可以调用的，比如 <strong>undefined.toString()</strong></p>
<pre><code class="language-js">let a = 111 // 这只是字面量，不是 number 类型 111为字面量 a为变量
a.toString() // 使用时候才会转换为 Number 对象类型
</code></pre>
<h3 id="对象object类型">对象（Object）类型</h3>
<p>在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是<strong>值</strong>，对象类型存储的是<strong>地址（指针）</strong>。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p>
<pre><code class="language-js">const a = []
</code></pre>
<p>对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001。</p>
<p>当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），当我们进行数据修改的时候，就会修改存放在地址（指针）上的值，也就导致了两个变量的值都发生了改变。</p>
<h2 id="typeof-instanceof">typeof | instanceof</h2>
<pre><code class="language-js">/**
 * typeof 对于原始类型来说，除了 null 都可以显示正确的类型
 */
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'

/**
 * typeof 对于对象来说，除了函数都会显示 object
 */
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'

/**
 * 如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof
 */
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
</code></pre>
<h2 id="类型转换">类型转换</h2>
<p>在 JS 中类型转换只有三种情况，分别是：</p>
<ul>
<li><strong>转换为布尔值</strong></li>
<li><strong>转换为数字</strong></li>
<li><strong>转换为字符串</strong></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://kaobeimao.github.io/post-images/1570696590205.png" alt=""></figure>
<h3 id="转换为布尔值">转换为布尔值</h3>
<p>在条件判断时，除了 undefined， null， false， NaN， &quot;&quot;， 0， -0，其他所有值都转为 true，包括所有对象。</p>
<h3 id="对象转原始类型">对象转原始类型</h3>
<p>对象在转换类型的时候，会调用内置的 <strong>[[ToPrimitive]]</strong> 函数</p>
<h2 id="四则运算符">四则运算符</h2>
<p>加法运算符，有以下特点：</p>
<ul>
<li><strong>运算中其中一方为字符串，那么就会把另一方也转换为字符串</strong></li>
<li><strong>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</strong></li>
</ul>
<pre><code class="language-js">1 + '1' // '11' 触发特点一，所以将数字 1 转换为字符串
true + true // 2 触发特点二，所以将 true 转为数字 1
4 + [1,2,3] // &quot;41,2,3&quot; 触发特点二，所以将数组通过 toString 转为字符串 1,2,3

/**
 * 因为 + 'b' 等于 NaN，所以结果为 &quot;aNaN&quot;，
 * 你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。
 */
'a' + + 'b' // -&gt; &quot;aNaN&quot;

/**
 * 除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字
 */
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
</code></pre>
<h2 id="比较运算符">比较运算符</h2>
<ol>
<li>如果是对象，就通过 toPrimitive 转换对象</li>
<li>如果是字符串，就通过 unicode 字符索引来比较</li>
</ol>
<pre><code class="language-js">/**
 * 因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值
 */
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a &gt; -1 // true
</code></pre>
<h2 id="this">this</h2>
<figure data-type="image" tabindex="2"><img src="https://kaobeimao.github.io/post-images/1571381565249.png" alt=""></figure>
<h2 id="">=== &amp; ==</h2>
<p>==流程：</p>
<ol>
<li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
<li>类型不相同的话，那么就会进行类型转换</li>
<li>会先判断是否在对比 <strong>null</strong> 和 <strong>undefined</strong>，是的话就会返回 <strong>true</strong></li>
<li>判断两者类型是否为 <strong>string</strong> 和 <strong>number</strong>，是的话就会将字符串转换为 <strong>number</strong><pre><code class="language-js">1 == '1'
      ↓
1 ==  1
</code></pre>
</li>
<li>判断其中一方是否为 <strong>boolean</strong>，是的话就会把 <strong>boolean</strong> 转为 <strong>number</strong> 再进行判断<pre><code class="language-js">'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
</code></pre>
</li>
<li>判断其中一方是否为 <strong>object</strong> 且另一方为 <strong>string</strong>、<strong>number</strong> 或者 <strong>symbol</strong>，是的话就会把 <strong>object</strong> 转为原始类型再进行判断<pre><code class="language-js">'1' == { name: 'yck' }
              ↓
'1' == '[object Object]'
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boolean Skill]]></title>
        <id>https://kaobeimao.github.io/post/P-LlCRZyP</id>
        <link href="https://kaobeimao.github.io/post/P-LlCRZyP">
        </link>
        <updated>2019-10-07T12:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="switchcase使用区间">switch/case使用区间</h2>
<pre><code class="language-js">const age = 26;
switch (true) {
    case isNaN(age):
        console.log(&quot;not a number&quot;);
        break;
    case (age &lt; 18):
        console.log(&quot;under age&quot;);
        break;
    case (age &gt;= 18):
        console.log(&quot;adult&quot;);
        break;
    default:
        console.log(&quot;please set your age&quot;);
        break;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拓展运算符]]></title>
        <id>https://kaobeimao.github.io/post/eSPILDxPr</id>
        <link href="https://kaobeimao.github.io/post/eSPILDxPr">
        </link>
        <updated>2019-10-07T11:19:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(字面量一般指 [1, 2, 3] 或者 {name: &quot;mdn&quot;} 这种简洁的构造方式)</p>
</blockquote>
<h2 id="数组的扩展">数组的扩展</h2>
<pre><code class="language-js">// 复制数组（浅拷贝）
const a1 = [1, 2]
const a2 = [...a1]

// 合并数组（浅拷贝）
const arr1 = ['1', '2']
const arr2 = ['c', {a:1}]
const arr3 = [...arr1, ...arr2]

/**
 * 将字符串转化为数组
 * 使用扩展运算符能够正确识别四个字节的 Unicode 字符。
 * 凡是涉及到操作四个字节的 Unicode 字  * 符的函数，都有这个问题。
 * 因此，最好都用扩展运算符改写。
 */
[...'wdnmd'] // [&quot;w&quot;, &quot;d&quot;, &quot;n&quot;, &quot;m&quot;, &quot;d&quot;]

// 实现了 Iterator 接口的对象
let nodeList = document.querySelectorAll('div')
let arr = [...nodeList]
</code></pre>
<h2 id="对象的拓展">对象的拓展</h2>
<pre><code class="language-js">/**
 * 对象的扩展运算符用于取出参数对象的所有可遍历属性,拷贝到当前对象之中
 * 等同于使用Object.assign()方法
 */
let a = {w: 'xu', y: 'xi'}
let b = {name: '12'}
let ab = { ...a, ...b }
// 等同于
let ab = Object.assign({}, a, b)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axios封装]]></title>
        <id>https://kaobeimao.github.io/post/cM6N64RQ8</id>
        <link href="https://kaobeimao.github.io/post/cM6N64RQ8">
        </link>
        <updated>2019-10-07T11:03:10.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">/**
 * axios封装
 * 请求拦截、响应拦截、错误统一处理
 */
import axios from 'axios'
import router from '../../router'
import store from '../../store/index'
import { Message } from 'element-ui'

/**
 * 提示函数
 * 禁止点击蒙层、显示一秒后关闭
 */
const tip = msg =&gt; {
    Message({
        type: 'error',
        message: msg
    })
}

/**
 * 跳转登录页
 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面
 */
const toLogin = () =&gt; {
    router.replace({
        path: '/login',
        query: {
            redirect: router.currentRoute.fullPath
        }
    })
}

/**
 * 请求失败后的错误统一处理
 * @param {Number}   请求失败的状态码
 */
const errorHandle = (status, other) =&gt; {
    // 状态码判断
    switch (status) {
        // 401: 未登录状态，跳转登录页
        case 401:
            toLogin()
            break
        // 403 token过期
        // 清除token并跳转登录页
        case 403:
            tip(`${status}:登录过期，请重新登录`)
            localStorage.removeItem('token')
            setTimeout(() =&gt; {
                toLogin()
            }, 1000)
            break
        // 404请求不存在
        case 404:
            tip(`${status}:请求的资源不存在`)
            break
        default:
            console.log(other)
    }
}

// 创建axios实例
let instance = axios.create({ timeout: 1000 * 12 })

// 设置post请求头
instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'

/**
 * 请求拦截器
 * 每次请求前，如果存在token则在请求头中携带token
 */
instance.interceptors.request.use(
    config =&gt; {
        // 登录流程控制中，根据本地是否存在token判断用户的登录情况
        // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token
        // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码
        // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。
        const token = store.state.token
        token &amp;&amp; (config.headers.Authorization = token)
        return config
    },
    error =&gt; Promise.error(error)
)

// 响应拦截器
instance.interceptors.response.use(
    // 请求成功
    res =&gt; (res.status === 200 ? Promise.resolve(res.data) : Promise.reject(res)),
    // 请求失败
    error =&gt; {
        const { response } = error
        if (response) {
            // 请求已发出，但是不在2xx的范围
            errorHandle(response.status, response.data.message)
            return Promise.reject(response)
        } else {
            // 处理断网的情况
            // eg:请求超时或断网时，更新state的network状态
            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏
            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明
            if (!window.navigator.onLine) {
            } else {
                return Promise.reject(error)
            }
        }
    }
)

export default instance
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数声明及表达式]]></title>
        <id>https://kaobeimao.github.io/post/han-shu-sheng-ming-ji-biao-da-shi</id>
        <link href="https://kaobeimao.github.io/post/han-shu-sheng-ming-ji-biao-da-shi">
        </link>
        <updated>2019-10-07T10:36:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数声明">函数声明</h2>
<pre><code class="language-js">function add() {}
</code></pre>
<h2 id="函数表达式">函数表达式</h2>
<pre><code class="language-js">const add = function() {}
or
const add = () =&gt; {}
</code></pre>
<h2 id="区别">区别</h2>
<pre><code class="language-js">foo(); // hello
function foo() {
  console.log('hello');
}

console.log(num); // undefined
var num = 1;
console.log(num); // 1
</code></pre>
<p>函数声明存在提升而函数表达式不会。</p>
<h2 id="小结">小结</h2>
<p>如果你想在让函数全局通用，在全局作用域上使用函数声明创建函数。<br>
函数表达式可以有效的避免污染全局作用域。比起你的代码中充斥着各种各样的具名函数，匿名函数可以让你使用后立即丢弃掉。使用函数表达式场景主要有<strong>IIFE</strong>、<strong>回调函数</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖&节流]]></title>
        <id>https://kaobeimao.github.io/post/fang-dou-andjie-liu</id>
        <link href="https://kaobeimao.github.io/post/fang-dou-andjie-liu">
        </link>
        <updated>2019-09-29T15:49:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce(func, wait = 50, immediate = true) {
    let timer, context, args

    // 延迟执行函数
    const later = () =&gt;
        setTimeout(() =&gt; {
            // 延迟函数执行完毕，清空缓存的定时器序号
            timer = null
            // 延迟执行的情况下，函数会在延迟函数中执行
            // 使用到之前缓存的参数和上下文
            if (!immediate) {
                func.apply(context, args)
                context = args = null
            }
        }, wait)

    // 这里返回的函数是每次实际调用的函数
    return function(...params) {
        // 如果没有创建延迟执行函数（later），就创建一个
        if (!timer) {
            timer = later()
            // 如果是立即执行，调用函数
            // 否则缓存参数和调用上下文
            if (immediate) {
                func.apply(this, params)
            } else {
                context = this
                args = params
            }
            // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
            // 这样做延迟函数会重新计时
        } else {
            clearTimeout(timer)
            timer = later()
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两数之和]]></title>
        <id>https://kaobeimao.github.io/post/liang-shu-zhi-he</id>
        <link href="https://kaobeimao.github.io/post/liang-shu-zhi-he">
        </link>
        <updated>2019-09-28T10:14:51.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h2 id="实现">实现</h2>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const obj = {}
    for(let i = nums.length ; i -- ;){
        const res = target - nums[i]
        if(res in obj) {
            return [i , obj[res]]        
        }
        obj[nums[i]] = i
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的精度问题]]></title>
        <id>https://kaobeimao.github.io/post/test</id>
        <link href="https://kaobeimao.github.io/post/test">
        </link>
        <updated>2019-09-26T07:06:50.000Z</updated>
        <content type="html"><![CDATA[<p>JS 采用 IEEE 754 双精度版本（64位）</p>
<pre><code class="language-js">parseFloat((0.1 + 0.2).toFixed(10))
</code></pre>
]]></content>
    </entry>
</feed>