<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kaobeimao.github.io</id>
    <title>kaobeimao</title>
    <updated>2019-09-29T15:54:01.544Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kaobeimao.github.io"/>
    <link rel="self" href="https://kaobeimao.github.io/atom.xml"/>
    <subtitle>舒服嗷铁汁</subtitle>
    <logo>https://kaobeimao.github.io/images/avatar.png</logo>
    <icon>https://kaobeimao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, kaobeimao</rights>
    <entry>
        <title type="html"><![CDATA[防抖&节流]]></title>
        <id>https://kaobeimao.github.io/post/fang-dou-andjie-liu</id>
        <link href="https://kaobeimao.github.io/post/fang-dou-andjie-liu">
        </link>
        <updated>2019-09-29T15:49:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce(func, wait = 50, immediate = true) {
    let timer, context, args

    // 延迟执行函数
    const later = () =&gt;
        setTimeout(() =&gt; {
            // 延迟函数执行完毕，清空缓存的定时器序号
            timer = null
            // 延迟执行的情况下，函数会在延迟函数中执行
            // 使用到之前缓存的参数和上下文
            if (!immediate) {
                func.apply(context, args)
                context = args = null
            }
        }, wait)

    // 这里返回的函数是每次实际调用的函数
    return function(...params) {
        // 如果没有创建延迟执行函数（later），就创建一个
        if (!timer) {
            timer = later()
            // 如果是立即执行，调用函数
            // 否则缓存参数和调用上下文
            if (immediate) {
                func.apply(this, params)
            } else {
                context = this
                args = params
            }
            // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
            // 这样做延迟函数会重新计时
        } else {
            clearTimeout(timer)
            timer = later()
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两数之和]]></title>
        <id>https://kaobeimao.github.io/post/liang-shu-zhi-he</id>
        <link href="https://kaobeimao.github.io/post/liang-shu-zhi-he">
        </link>
        <updated>2019-09-28T10:14:51.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>
<strong>示例</strong></p>
<pre><code class="language-js">给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p><strong>实现</strong></p>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const obj = {}
    for(let i = nums.length ; i -- ;){
        const res = target - nums[i]
        if(res in obj) {
            return [i , obj[res]]        
        }
        obj[nums[i]] = i
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的精度问题]]></title>
        <id>https://kaobeimao.github.io/post/test</id>
        <link href="https://kaobeimao.github.io/post/test">
        </link>
        <updated>2019-09-26T07:06:50.000Z</updated>
        <content type="html"><![CDATA[<p>JS 采用 IEEE 754 双精度版本（64位）</p>
<pre><code class="language-js">parseFloat((0.1 + 0.2).toFixed(10))
</code></pre>
]]></content>
    </entry>
</feed>