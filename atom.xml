<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kaobeimao.github.io</id>
    <title>kaobeimao</title>
    <updated>2019-10-07T12:31:19.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kaobeimao.github.io"/>
    <link rel="self" href="https://kaobeimao.github.io/atom.xml"/>
    <subtitle>舒服嗷铁汁</subtitle>
    <logo>https://kaobeimao.github.io/images/avatar.png</logo>
    <icon>https://kaobeimao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, kaobeimao</rights>
    <entry>
        <title type="html"><![CDATA[Boolean Skill]]></title>
        <id>https://kaobeimao.github.io/post/P-LlCRZyP</id>
        <link href="https://kaobeimao.github.io/post/P-LlCRZyP">
        </link>
        <updated>2019-10-07T12:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="switchcase使用区间">switch/case使用区间</h2>
<pre><code class="language-js">const age = 26;
switch (true) {
    case isNaN(age):
        console.log(&quot;not a number&quot;);
        break;
    case (age &lt; 18):
        console.log(&quot;under age&quot;);
        break;
    case (age &gt;= 18):
        console.log(&quot;adult&quot;);
        break;
    default:
        console.log(&quot;please set your age&quot;);
        break;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拓展运算符]]></title>
        <id>https://kaobeimao.github.io/post/eSPILDxPr</id>
        <link href="https://kaobeimao.github.io/post/eSPILDxPr">
        </link>
        <updated>2019-10-07T11:19:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(字面量一般指 [1, 2, 3] 或者 {name: &quot;mdn&quot;} 这种简洁的构造方式)</p>
</blockquote>
<h2 id="数组的扩展">数组的扩展</h2>
<pre><code class="language-js">// 复制数组（浅拷贝）
const a1 = [1, 2]
const a2 = [...a1]

// 合并数组（浅拷贝）
const arr1 = ['1', '2']
const arr2 = ['c', {a:1}]
const arr3 = [...arr1, ...arr2]

/**
 * 将字符串转化为数组
 * 使用扩展运算符能够正确识别四个字节的 Unicode 字符。
 * 凡是涉及到操作四个字节的 Unicode 字  * 符的函数，都有这个问题。
 * 因此，最好都用扩展运算符改写。
 */
[...'wdnmd'] // [&quot;w&quot;, &quot;d&quot;, &quot;n&quot;, &quot;m&quot;, &quot;d&quot;]

// 实现了 Iterator 接口的对象
let nodeList = document.querySelectorAll('div')
let arr = [...nodeList]
</code></pre>
<h2 id="对象的拓展">对象的拓展</h2>
<pre><code class="language-js">/**
 * 对象的扩展运算符用于取出参数对象的所有可遍历属性,拷贝到当前对象之中
 * 等同于使用Object.assign()方法
 */
let a = {w: 'xu', y: 'xi'}
let b = {name: '12'}
let ab = { ...a, ...b }
// 等同于
let ab = Object.assign({}, a, b)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axios封装]]></title>
        <id>https://kaobeimao.github.io/post/cM6N64RQ8</id>
        <link href="https://kaobeimao.github.io/post/cM6N64RQ8">
        </link>
        <updated>2019-10-07T11:03:10.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">/**
 * axios封装
 * 请求拦截、响应拦截、错误统一处理
 */
import axios from 'axios'
import router from '../../router'
import store from '../../store/index'
import { Message } from 'element-ui'

/**
 * 提示函数
 * 禁止点击蒙层、显示一秒后关闭
 */
const tip = msg =&gt; {
    Message({
        type: 'error',
        message: msg
    })
}

/**
 * 跳转登录页
 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面
 */
const toLogin = () =&gt; {
    router.replace({
        path: '/login',
        query: {
            redirect: router.currentRoute.fullPath
        }
    })
}

/**
 * 请求失败后的错误统一处理
 * @param {Number}   请求失败的状态码
 */
const errorHandle = (status, other) =&gt; {
    // 状态码判断
    switch (status) {
        // 401: 未登录状态，跳转登录页
        case 401:
            toLogin()
            break
        // 403 token过期
        // 清除token并跳转登录页
        case 403:
            tip(`${status}:登录过期，请重新登录`)
            localStorage.removeItem('token')
            setTimeout(() =&gt; {
                toLogin()
            }, 1000)
            break
        // 404请求不存在
        case 404:
            tip(`${status}:请求的资源不存在`)
            break
        default:
            console.log(other)
    }
}

// 创建axios实例
let instance = axios.create({ timeout: 1000 * 12 })

// 设置post请求头
instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'

/**
 * 请求拦截器
 * 每次请求前，如果存在token则在请求头中携带token
 */
instance.interceptors.request.use(
    config =&gt; {
        // 登录流程控制中，根据本地是否存在token判断用户的登录情况
        // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token
        // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码
        // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。
        const token = store.state.token
        token &amp;&amp; (config.headers.Authorization = token)
        return config
    },
    error =&gt; Promise.error(error)
)

// 响应拦截器
instance.interceptors.response.use(
    // 请求成功
    res =&gt; (res.status === 200 ? Promise.resolve(res.data) : Promise.reject(res)),
    // 请求失败
    error =&gt; {
        const { response } = error
        if (response) {
            // 请求已发出，但是不在2xx的范围
            errorHandle(response.status, response.data.message)
            return Promise.reject(response)
        } else {
            // 处理断网的情况
            // eg:请求超时或断网时，更新state的network状态
            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏
            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明
            if (!window.navigator.onLine) {
            } else {
                return Promise.reject(error)
            }
        }
    }
)

export default instance
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数声明及表达式]]></title>
        <id>https://kaobeimao.github.io/post/han-shu-sheng-ming-ji-biao-da-shi</id>
        <link href="https://kaobeimao.github.io/post/han-shu-sheng-ming-ji-biao-da-shi">
        </link>
        <updated>2019-10-07T10:36:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数声明">函数声明</h2>
<pre><code class="language-js">function add() {}
</code></pre>
<h2 id="函数表达式">函数表达式</h2>
<pre><code class="language-js">const add = function() {}
or
const add = () =&gt; {}
</code></pre>
<h2 id="区别">区别</h2>
<pre><code class="language-js">foo(); // hello
function foo() {
  console.log('hello');
}

console.log(num); // undefined
var num = 1;
console.log(num); // 1
</code></pre>
<p>函数声明存在提升而函数表达式不会。</p>
<h2 id="小结">小结</h2>
<p>如果你想在让函数全局通用，在全局作用域上使用函数声明创建函数。<br>
函数表达式可以有效的避免污染全局作用域。比起你的代码中充斥着各种各样的具名函数，匿名函数可以让你使用后立即丢弃掉。使用函数表达式场景主要有<strong>IIFE</strong>、<strong>回调函数</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖&节流]]></title>
        <id>https://kaobeimao.github.io/post/fang-dou-andjie-liu</id>
        <link href="https://kaobeimao.github.io/post/fang-dou-andjie-liu">
        </link>
        <updated>2019-09-29T15:49:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce(func, wait = 50, immediate = true) {
    let timer, context, args

    // 延迟执行函数
    const later = () =&gt;
        setTimeout(() =&gt; {
            // 延迟函数执行完毕，清空缓存的定时器序号
            timer = null
            // 延迟执行的情况下，函数会在延迟函数中执行
            // 使用到之前缓存的参数和上下文
            if (!immediate) {
                func.apply(context, args)
                context = args = null
            }
        }, wait)

    // 这里返回的函数是每次实际调用的函数
    return function(...params) {
        // 如果没有创建延迟执行函数（later），就创建一个
        if (!timer) {
            timer = later()
            // 如果是立即执行，调用函数
            // 否则缓存参数和调用上下文
            if (immediate) {
                func.apply(this, params)
            } else {
                context = this
                args = params
            }
            // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
            // 这样做延迟函数会重新计时
        } else {
            clearTimeout(timer)
            timer = later()
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两数之和]]></title>
        <id>https://kaobeimao.github.io/post/liang-shu-zhi-he</id>
        <link href="https://kaobeimao.github.io/post/liang-shu-zhi-he">
        </link>
        <updated>2019-09-28T10:14:51.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h2 id="实现">实现</h2>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const obj = {}
    for(let i = nums.length ; i -- ;){
        const res = target - nums[i]
        if(res in obj) {
            return [i , obj[res]]        
        }
        obj[nums[i]] = i
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮点数的精度问题]]></title>
        <id>https://kaobeimao.github.io/post/test</id>
        <link href="https://kaobeimao.github.io/post/test">
        </link>
        <updated>2019-09-26T07:06:50.000Z</updated>
        <content type="html"><![CDATA[<p>JS 采用 IEEE 754 双精度版本（64位）</p>
<pre><code class="language-js">parseFloat((0.1 + 0.2).toFixed(10))
</code></pre>
]]></content>
    </entry>
</feed>